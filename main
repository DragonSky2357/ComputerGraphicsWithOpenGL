////#include<GL/glut.h>
////#include <stdlib.h>
////
////void init(void) {
////	glClearColor(0.0, 0.0, 0.0, 0.0);
////	glShadeModel(GL_SMOOTH);
////}
////
////void triangle(void) {
////	glBegin(GL_TRIANGLES);
////	glColor3f(1.0, 0.0, 0.0);
////	glVertex2f(-0.5, -0.5);
////	glColor3f(0.0, 1.0, 0.0);
////	glVertex2f(0.5, -0.5);
////	glColor3f(0.0, 0.0, 1.0);
////	glVertex2f(-0.5, 0.5);
////	glEnd();
////}
////
////void display(void) {
////	glClear(GL_COLOR_BUFFER_BIT);
////	triangle();
////	glFlush();
////}
////
////void reshape(int new_w, int new_h) {
////	glViewport(0, 0, new_w, new_h);
////	float WidthFactor = (float)new_w / 300.0;
////	float HeightFactor = (float)new_h / 300.0;
////
////	glMatrixMode(GL_PROJECTION);
////	glLoadIdentity();
////
////	gluOrtho2D(-1.0 * WidthFactor, 1.0 * WidthFactor, -1.0*HeightFactor, 1.0*HeightFactor);
////}
////
////int main(int argc, char** argv) {
////	glutInit(&argc, argv);
////	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
////	glutInitWindowSize(300, 300);
////	glutInitWindowPosition(100, 100);
////	glutCreateWindow(argv[0]);
////	init();
////	glutDisplayFunc(display);
////	glutReshapeFunc(reshape);
////	glutMainLoop();
////	return 0;
////}
//
////#include<GL/glut.h>
////#include <stdio.h>
////#include <stdlib.h>
////
////void init(void) {
////	glClearColor(0.0, 0.0, 0.0, 0.0);
////}
////
////void display(void) {
////	glClear(GL_COLOR_BUFFER_BIT);
////	glClearColor(0.0, 0.0, 0.0, 0.0);
////	glFlush();
////}
////
////void mouseProcess(int button, int state, int x, int y) {
////	if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) 
////		printf("Left mouse button is pressed.. \a\n");
////	else if (button == GLUT_MIDDLE_BUTTON && state == GLUT_DOWN)
////		printf("Middle mouse button is pressed.. \a\n");
////	else if (button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN)
////		printf("Right mouse button is pressed.. \a\n");
////	else if (button == GLUT_LEFT_BUTTON && state == GLUT_UP)
////		printf("Left mouse button is released.. \a\n");
////	else if (button == GLUT_MIDDLE_BUTTON && state == GLUT_UP)
////		printf("Middle mouse button is released.. \a\n");
////	else if (button == GLUT_RIGHT_BUTTON && state == GLUT_UP)
////		printf("Right mouse button is released.. \a\n");
////
////}
////
////void mousePassiveMotaion(int x, int y) {
////	printf("Current mouse position: %d, %d\n", x, y);
////}
////
////void mouseActiveMotion(int x, int y) {
////	printf("Pressed mouse position: %d, %d\n", x, y);
////}
////
////void mouseEntry(int state) {
////	if (state == GLUT_LEFT)
////		printf("Mouse is outside of window..\a\n");
////	else if (state == GLUT_ENTERED)
////		printf("Mouse is inside of window..\a\n");
////}
////
////void keyboard(unsigned char key, int x, int y) {
////	switch (key)
////	{
////	case 'a':
////		printf("a is pressed.. %d, %d\a\n", x, y);
////		break;
////	case 'b':
////		printf("b is pressed.. %d, %d\a\n", x, y);
////		break;
////
////	case 27:
////		exit(0);
////		break;
////	}
////}
////
////int main(int argc, char** argv) {
////	glutInit(&argc, argv);
////	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
////	glutInitWindowSize(500, 500);
////	glutInitWindowPosition(100, 100);
////	glutCreateWindow("Mouse and keyboard");
////	init();
////	glutDisplayFunc(display);
////	glutKeyboardFunc(keyboard);
////	glutMouseFunc(mouseProcess);
////	glutMainLoop();
////	return 0;
////}
//
////#include <GL/glut.h>
////#include <stdlib.h>
////#include <stdio.h>
////
////#define size 50.0
////
////float w_height = 800;
////float w_width = 800;
////float square_x = 0, square_y = 400;
////float square_dx = 0.1;
////
////void idleCallBack() {
////	square_x += square_dx;
////	if (square_x + size > w_width || square_x < 0) square_dx *= -1.0;
////	glutPostRedisplay();
////}
////
////void displayCallBack(void) {
////	glClearColor(0.0, 0.0, 0.0, 1.0);
////	glClear(GL_COLOR_BUFFER_BIT);
////
////	glMatrixMode(GL_PROJECTION);
////	glLoadIdentity();
////	glOrtho(0.0, w_width, 0.0, w_height, -1.0, 1.0);
////
////	glMatrixMode(GL_MODELVIEW);
////	glLoadIdentity();
////	glTranslatef(square_x, square_y, 0.0);
////
////	glColor3ub(255, 255, 0);
////	glBegin(GL_POLYGON);
////	glVertex2f(0, 0);
////	glVertex2f(size, 0);
////	glVertex2f(size, size);
////	glVertex2f(0, size);
////	glEnd();
////
////	glutSwapBuffers();
////}
////
////void main(int argc, char** argv) {
////	glutInit(&argc, argv);
////
////	glutInitWindowPosition(10, 10);
////	glutInitWindowSize(w_width, w_height);
////	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
////	glutCreateWindow("Idle Callback");
////
////	glutDisplayFunc(displayCallBack);
////	glutIdleFunc(idleCallBack);
////
////	glutMainLoop();
////}
//

//#include <GL/glut.h>
//#include <GL/GLU.h>
//#include <GL/GL.h>
//#include <time.h>
//
//unsigned char PALETTE[16][3] = {
//	{255,255,255},
//	{0,255,255},
//	{255,0,255},
//	{0,0,255},
//	{192,192,192},
//	{128,128,128},
//	{0,128,128},
//	{128,0,128},
//	{0,0,128},
//	{255,255,0},
//	{0,255,0},
//	{128,128,0},
//	{0,128,0},
//	{255,0,0},
//	{128,0,0},
//	{0,0,0},
//};
//
//GLfloat Delta = 0.0;
//GLint Index = 0;
//GLfloat Red = 0.0;
//GLfloat Green = 0.0;
//GLfloat Blue = 0.0;
//
//void MyDisplay() {
//	Red = PALETTE[Index][0] / 255.0f;
//	Green = PALETTE[Index][1] / 255.0f;
//	Blue = PALETTE[Index][2] / 255.0f;
//	glColor3f(Red, Green, Blue);
//
//	glBegin(GL_LINES);
//	glVertex3f(-1.0 + Delta, 1.0, 0.0);
//	glVertex3f(1.0 - Delta, -1.0, 0.0);
//	glVertex3f(-1.0, -1.0 + Delta, 0.0);
//	glVertex3f(1.0, 1.0 - Delta, 0.0);
//	glEnd();
//	glutSwapBuffers();
//}
//
//void MyTimer(int value) {
//	if (Delta < 2.0f)Delta = Delta + 0.01;
//	else {
//		Delta = 0.0;
//		if (++Index >= 15) {
//			Index = 0;
//			glClear(GL_COLOR_BUFFER_BIT);
//		}
//	}
//	glutPostRedisplay();
//	glutTimerFunc(10, MyTimer, 1);
//}
//
//int main(int argc, char** argv) {
//	glutInit(&argc, argv);
//	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
//	glutInitWindowSize(500, 500);
//	glutInitWindowPosition(0, 0);
//	glutCreateWindow("Timer Callback 예제");
//	glClearColor(0.0, 0.0, 0.0, 1.0);
//	glMatrixMode(GL_PROJECTION);
//	glLoadIdentity();
//	glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
//	glutTimerFunc(10, MyTimer, 1);
//	glutDisplayFunc(MyDisplay);
//	glutMainLoop();
//	return 0;
//}

//#include <GL/glut.h>
//#include <GL/GLU.h>
//#include <GL/GL.h>
//#include <time.h>
//#include <stdlib.h>
//
//static GLfloat spin = 0.0;
//
//void display(void) {
//	int r, g, b;
//	r = rand() % 256;
//	g = rand() % 256;
//	b = rand() % 256;
//
//	glClear(GL_COLOR_BUFFER_BIT);
//
//	glPushMatrix();
//	glRotatef(spin, 0.0, 0.0, 1.0);
//	glColor3f((GLfloat)r / 255, (GLfloat)g / 255, (GLfloat)b / 255);
//	glRectf(-25.0, -25.0, 25.0, 25.0);
//	glPopMatrix();
//
//	glutSwapBuffers();
//}
//
//void spinDisplay(void) {
//	spin = spin + 0.01;
//	if (spin > 360.0) spin = spin - 360.0;
//	glutPostRedisplay();
//}
//
//void init(void) {
//	glClearColor(0.0, 0.0, 0.0, 0.0);
//	glShadeModel(GL_FLAT);
//}
//
//void reshape(int w, int h) {
//	glViewport(0, 0, (GLsizei)w, (GLsizei)h);
//	glMatrixMode(GL_PROJECTION);
//	glLoadIdentity();
//	glOrtho(-50.0, 50.0, -50.0, 50.0, -1.0, 1.0);
//	glMatrixMode(GL_MODELVIEW);
//	glLoadIdentity();
//}
//
//void mouse(int button, int state, int x, int y) {
//	switch (button)
//	{
//	case GLUT_LEFT_BUTTON:
//		if (state == GLUT_DOWN) glutIdleFunc(spinDisplay);
//		break;
//	case GLUT_RIGHT_BUTTON:
//		if (state == GLUT_DOWN) glutIdleFunc(NULL);
//		break;
//	
//	default:
//		break;
//	}
//}
//int main(int argc, char** argv) {
//	glutInit(&argc, argv);
//	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
//	glutInitWindowSize(250, 250);
//	glutInitWindowPosition(100, 100);
//	glutCreateWindow("02_5 사각형 회전");
//	init();
//	glutDisplayFunc(display);
//	glutReshapeFunc(reshape);
//	glutMouseFunc(mouse);
//	glutMainLoop();
//	return 0;
//}

//#include <GL/glut.h>
//#include <GL/GLU.h>
//#include <GL/GL.h>
//#include <time.h>
//#include <stdlib.h>
//
//static GLfloat spin = 0.0;
//
//void display(void) {
//	int r, g, b;
//	r = rand() % 256;
//	g = rand() % 256;
//	b = rand() % 256;
//
//	glClear(GL_COLOR_BUFFER_BIT);
//
//	glPushMatrix();
//	glRotatef(spin, 0.0, 0.0, 1.0);
//	glColor3f((GLfloat)r / 255, (GLfloat)g / 255, (GLfloat)b / 255);
//	glPopMatrix();
//
//	glutSwapBuffers();
//}
//
//void spinDisplay(void) {
//	spin = spin + 0.01;
//	if (spin > 360.0) spin = spin - 360.0;
//	glutPostRedisplay();
//}
//
//void init(void) {
//	glClearColor(0.0, 0.0, 0.0, 0.0);
//	glShadeModel(GL_FLAT);
//}
//
//void reshape(int w, int h) {
//	glViewport(0, 0, (GLsizei)w, (GLsizei)h);
//	glMatrixMode(GL_PROJECTION);
//	glLoadIdentity();
//	glOrtho(-50.0, 50.0, -50.0, 50.0, -1.0, 1.0);
//	glMatrixMode(GL_MODELVIEW);
//	glLoadIdentity();
//}
//
//void mouse(int button, int state, int x, int y) {
//	switch (button)
//	{
//	case GLUT_LEFT_BUTTON:
//		if (state == GLUT_DOWN) glutIdleFunc(spinDisplay);
//		break;
//	case GLUT_RIGHT_BUTTON:
//		if (state == GLUT_DOWN) glutIdleFunc(NULL);
//		break;
//
//	default:
//		break;
//	}
//}
//int main(int argc, char** argv) {
//	glutInit(&argc, argv);
//	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
//	glutInitWindowSize(250, 250);
//	glutInitWindowPosition(100, 100);
//	glutCreateWindow("02_5 사각형 회전");
//	init();
//	glutDisplayFunc(display);
//	glutReshapeFunc(reshape);
//	glutMouseFunc(mouse);
//	glutMainLoop();
//	return 0;
//}

//#include<GL/glut.h>
//#include <stdlib.h>
//
//float v1[3] = { 75.0,400.0,0.0 };
//float v2[3] = { 150.0,100.0,0.0 };
//float v3[3] = { 225.0,400.0,0.0 };
//float v4[3] = { 300.0,100.0,0.0 };
//float v5[3] = { 375.0,400.0,0.0 };
//float v6[3] = { 450.0,100.0,0.0 };
//
//void init(void) {
//	glClearColor(0.0, 0.0, 0.0, 0.0);
//	glMatrixMode(GL_PROJECTION);
//	glLoadIdentity();
//	gluOrtho2D(0.0, 500.0, 0.0, 500.0);
//}
//
//void draw_points() {
//	glColor3f(1.0, 0.0, 0.0);
//
//	glPointSize(4);
//	glBegin(GL_POINTS);
//	glVertex3fv(v1);
//	glVertex3fv(v2);
//	glVertex3fv(v3);
//	glVertex3fv(v4);
//	glVertex3fv(v5);
//	glVertex3fv(v6);
//	glEnd();
//}
//
//void draw_lines() {
//	glColor3f(0.0, 1.0, 0.0);
//
//	glLineWidth(1);
//	glBegin(GL_LINES);
//	glVertex3fv(v1);
//	glVertex3fv(v2);
//	glVertex3fv(v3);
//	glVertex3fv(v4);
//	glVertex3fv(v5);
//	glVertex3fv(v6);
//	glEnd();
//}
//
//void draw_triangle_fan() {
//	glColor3f(0.0, 1.0, 0.0);
//
//	glBegin(GL_TRIANGLE_FAN);
//	glVertex3fv(v1);
//	glVertex3fv(v2);
//	glVertex3fv(v3);
//	glVertex3fv(v4);
//	glVertex3fv(v5);
//	glVertex3fv(v6);
//	glEnd();
//}
//
//void draw_eqads() {
//	glColor3f(0.0, 1.0, 0.0);
//
//	glBegin(GL_QUADS);
//	glVertex3fv(v1);
//	glVertex3fv(v2);
//	glVertex3fv(v4);
//	glVertex3fv(v3);
//	glEnd();
//}
//
//void draw_quad_strip() {
//	glColor3f(0.0, 1.0, 0.0);
//
//	glBegin(GL_QUAD_STRIP);
//	glVertex3fv(v1);
//	glVertex3fv(v2);
//	glVertex3fv(v3);
//	glVertex3fv(v4);
//	glVertex3fv(v5);
//	glVertex3fv(v6);
//	glEnd();
//}
//
//void draw_polygon() {
//	glColor3f(0.0, 1.0, 0.0);
//
//	glBegin(GL_POLYGON);
//	glVertex3fv(v1);
//	glVertex3fv(v2);
//	glVertex3fv(v4);
//	glVertex3fv(v5);
//	glVertex3fv(v3);
//	glEnd();
//}
//
//void display(void) {
//	glClear(GL_COLOR_BUFFER_BIT);
//	//draw_points();
//	//draw_triangle_fan();
//	//draw_eqads();
//	//draw_polygon();
//	//draw_polygon();
//	glFlush();
//}
//
//int main(int argc, char** argv) {
//	glutInit(&argc, argv);
//	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
//	glutInitWindowSize(500, 500);
//	glutInitWindowPosition(300, 300);
//	glutCreateWindow("My first GL Program");
//	init();
//
//	glutDisplayFunc(display);
//	glutMainLoop();
//
//	return 0;
//}

#include <GL/glut.h>
#include <stdlib.h>

#define drawOneLine(x1,y1,x2,y2) glBegin(GL_LINES); \
	glVertex2f ((x1),(y1)); glVertex2f ((x2),(y2)); glEnd();

void init(void) {
	glClearColor(0.0, 0.0, 0.0, 0.0);
	glShadeModel(GL_FLAT);
}

void display(void) {
	int i;

	glClear(GL_COLOR_BUFFER_BIT);

	glColor3f(1.0, 1.0, 1.0);

	glEnable(GL_LINE_STIPPLE);

	glLineStipple(1, 0x0101);
	drawOneLine(50.0, 125.0, 150.0, 125.0);
	glLineStipple(1, 0x00FF);
	drawOneLine(150.0, 125.0, 250.0, 125.0);
	glLineStipple(1, 0x1C47);
	drawOneLine(250.0, 125.0, 350.0, 125.0);

	glLineWidth(5.0);
	glLineStipple(1, 0x0101);
	drawOneLine(50.0, 100.0, 150.0, 100.0);
	glLineStipple(1, 0x00FF);
	drawOneLine(150.0, 100.0, 250.0, 100.0);
	glLineStipple(1, 0x1C47);
	drawOneLine(250.0, 100.0, 350.0, 100.0);
	glLineWidth(1.0);

	glLineStipple(1, 0x1C47);
	glBegin(GL_LINE_STRIP);
		for (i = 0; i < 7; i++) glVertex2f(50.0 + ((GLfloat)i*50.0), 75.0);
	glEnd();
	
	for (i = 0; i < 6; i++)
		drawOneLine(50.0 + ((GLfloat)i*50.0), 50.0, 50.0 + ((GLfloat)(i + 1)*50.0), 50.0);

	glLineStipple(5, 0x4C47);
	drawOneLine(50.0, 25.0, 350.0, 25.0);

	glDisable(GL_LINE_STIPPLE);
	glFlush();
}

void reshape(int w, int h) {
	glViewport(0, 0, (GLsizei)w, (GLsizei)h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0.0, (GLdouble)w, 0.0, (GLdouble)h);
}

void keyboard(unsigned char key, int x, int y) {
	switch (key)
	{
	case 27:
		exit(0);
		break;
	}
}

int main(int argc, char** argv) {
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(400, 150);
	glutInitWindowPosition(100, 100);
	glutCreateWindow("My first GL Program");
	init();

	glutDisplayFunc(display);
	glutReshapeFunc(reshape);
	glutKeyboardFunc(keyboard);
	glutMainLoop();

	return 0;
}
